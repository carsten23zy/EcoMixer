#include "mixbox.h"

#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>

std::vector<float> solveLeastSquares(const std::vector<std::vector<float>>& A, const std::vector<float>& b) {  //Generated by GPT-4o
    int rows = A.size();
    int cols = A[0].size();
    std::vector<std::vector<float>> At(cols, std::vector<float>(rows, 0));
    std::vector<std::vector<float>> AtA(cols, std::vector<float>(cols, 0));
    std::vector<float> Atb(cols, 0);
    std::vector<float> x(cols, 0);

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            At[j][i] = A[i][j];
        }
    }

    for (int i = 0; i < cols; i++) {
        for (int j = 0; j < cols; j++) {
            for (int k = 0; k < rows; k++) {
                AtA[i][j] += At[i][k] * A[k][j];
            }
        }
    }

    for (int i = 0; i < cols; i++) {
        for (int j = 0; j < rows; j++) {
            Atb[i] += At[i][j] * b[j];
        }
    }

    for (int i = 0; i < cols; i++) {
        float maxEl = std::abs(AtA[i][i]); // Use std::abs for floating-point numbers
        int maxRow = i;
        for (int k = i + 1; k < cols; k++) {
            if (std::abs(AtA[k][i]) > maxEl) {
                maxEl = std::abs(AtA[k][i]);
                maxRow = k;
            }
        }

        for (int k = i; k < cols; k++) {
            std::swap(AtA[maxRow][k], AtA[i][k]);
        }
        std::swap(Atb[maxRow], Atb[i]);

        for (int k = i + 1; k < cols; k++) {
            float c = -AtA[k][i] / AtA[i][i];
            for (int j = i; j < cols; j++) {
                if (i == j) {
                    AtA[k][j] = 0;
                } else {
                    AtA[k][j] += c * AtA[i][j];
                }
            }
            Atb[k] += c * Atb[i];
        }
    }

    for (int i = cols - 1; i >= 0; i--) {
        x[i] = Atb[i] / AtA[i][i];
        for (int k = i - 1; k >= 0; k--) {
            Atb[k] -= AtA[k][i] * x[i];
        }
    }

    return x;
}

std::vector<float> findWeights(const std::vector<float>& rgb1, 
                               const std::vector<float>& rgb2, 
                               const std::vector<float>& rgb3, 
                               const std::vector<float>& target_rgb) {
    
  mixbox_latent z1, z2, z3, z_target;
	unsigned char r1 = rgb1[0], g1 = rgb1[1], b1 = rgb1[2];
	unsigned char r2 = rgb2[0], g2 = rgb2[1], b2 = rgb2[2];
	unsigned char r3 = rgb3[0], g3 = rgb3[1], b3 = rgb3[2];
	unsigned char rt = target_rgb[0], gt = target_rgb[1], bt = target_rgb[2];
	
	mixbox_rgb_to_latent(r1, g1, b1, z1);
	mixbox_rgb_to_latent(r2, g2, b2, z2);
	mixbox_rgb_to_latent(r3, g3, b3, z3);
	mixbox_rgb_to_latent(rt, gt, bt, z_target);

  std::vector<std::vector<float>> A = { {z1[0], z2[0], z3[0]},
                                {z1[1], z2[1], z3[1]},
                                {z1[2], z2[2], z3[2]}, 
                                {z1[3], z2[3], z3[3]},
                                {z1[4], z2[4], z3[4]},
                                {z1[5], z2[5], z3[5]},
                                {z1[6], z2[6], z3[6]} };
                            
  std::vector<float> b = {z_target[0], z_target[1], z_target[2],
                          z_target[3], z_target[4], z_target[5], 
                          z_target[6]};

  return solveLeastSquares(A, b);
}